/*
* Project2.c
*
* Created: 4/9/2024 11:06:14 AM
* Author : Westin Gjervold
*/

#include <avr/io.h>
#include <stdio.h>
#include <avr/cpufunc.h>
#include <avr/interrupt.h>
#define F_CPU 20000000
#include <util/delay.h>

#define F_PER 20000000
#define THREE_5V 716
#define MAXCOUNT 20
#define STEP_SIZE 63
#define USART3_BAUD_RATE(BAUD_RATE) ((float)(F_CPU * 64 / (16 * (float)BAUD_RATE)) + 0.5)

uint16_t adc_result;
uint16_t adc_voltage;
uint16_t period;
uint16_t highTime;
uint16_t lowTime;
uint8_t newADCDataFlag = 0;
uint8_t newTimerDataFlag = 0;
uint16_t continuousTimerMode = 0;
uint16_t continuousADCMode = 0;
uint8_t interruptCounter = 0;
uint8_t numberOfInterrupts;
uint16_t servoCounter = 0;
uint8_t leftOrRight = 0;
uint8_t stopServo = 1;
char input;
unsigned char qcntr = 0,sndcntr = 0;
unsigned char queue[50];
char message[50];

void displayMessage(char input);
void sendmsg (char *s);

void clock_init (void) {
	ccp_write_io( (void *) &CLKCTRL.MCLKCTRLB , (0 << CLKCTRL_PEN_bp));
}

void init_outputs(void) {
	PORTA.DIRSET = 0b00000011; //LED bit 2 and Servomotor PWM output
	PORTC.DIRSET = 0b01000000; //LED bit 4
	PORTF.DIRSET = 0b00110000; //LED bit 3 and 6
}

void EVSYS_Init(void) {
	EVSYS.CHANNEL4 = EVSYS_GENERATOR_PORT0_PIN3_gc;		//Set the EVSYS Channel 4 generator to be PORTE Bit 3
	EVSYS.USERTCB0 = EVSYS_CHANNEL_CHANNEL4_gc;			//Set the EVSYS Channel 4 User to be TCB0
	EVSYS.CHANNEL0 = EVSYS_GENERATOR_TCB3_CAPT_gc;		//Set the EVSYS Channel 0 generator to be TCB3 CAPT (this will be TCB3 overflow in this case)
	EVSYS.USERADC0 = EVSYS_CHANNEL_CHANNEL0_gc;			//Set the EVSYS Channel 0 User to be ADC0
}

void WG_SSPWM_init(void) {
	PORTA.DIRSET = PIN1_bm;		// WO-1 used for PWM
	TCA0.SINGLE.CTRLA = (TCA_SINGLE_CLKSEL_DIV16_gc | TCA_SINGLE_ENABLE_bm);		//Set CLK_PER divided by 16 and TCA0 enabled (CTRLA)		
	TCA0.SINGLE.CTRLB = (TCA_SINGLE_CMP1EN_bm | TCA_SINGLE_WGMODE_SINGLESLOPE_gc);	//Set TCA0 to Single Slope PWM (CTRLB)
	TCA0.SINGLE.PER = 24999;	//Set TCA.SINGLE.PER or PERBUF for 50Hz PWM frequency (24999)
	TCA0.SINGLE.CMP1 = 1250;	//Set TCA0.SINGLE.CMP1 for nominal -90degrees initial position (1250)
	//No Interrupts
}

void TCB0_init(void) {
	TCB0.CTRLA = TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm; //Set CLK_PER/2 and Enable TCB0 (CTRLA)
	TCB0.CTRLB = TCB_CNTMODE_FRQPW_gc;					//Configure TCB0 in Clock Frequency - Pulse Width Measurement mode (CTRLB)
	TCB0.INTCTRL = TCB_CAPT_bm;							//Enable Capture interrupt (INTCTRL)
	TCB0.EVCTRL = 0b00010001;							//Enable Event Input and Falling Event Edge (EVCTRL)
}

void TCB1_init(void) {
	TCB1.CTRLA = 0b00000011;	//Set CLK_PER/2 and Enable TCB1 (CTRLA)
	//The remaining settings are left as a challenge.
}

void TCB3_init(void) {
	TCB3.CTRLA = 0b00000011;		//Timer/Counter TCB3 Clock source: CLK_PER/2 and Enable TCB3 (CTRLA)
	TCB3.CTRLB = 0b00000000;		//Configure TCB3 for Periodic Interrupt Mode (CTRLB)
	TCB3.INTCTRL = TCB_CAPT_bm;		//TCB3 interrupts enabled
	TCB3.CCMP = 50000;				//Set TCB3.CCMP to give a period of 5ms.
}

void ADC0_init(void){
	ADC0.MUXPOS = 0b00000011;	//ADC0 AIN3 used (MUXPOS)
	ADC0.CTRLA = 0b00000001;	//10-bit resolution, Free Running Mode NOT selected, ADC0 enabled
	ADC0.CTRLB = 0b00000000;	//Simple conversion selected (no sample accumulation)
	ADC0.CTRLC = 0b00010101;	//ADC0 clock prescaler: 64, AVDD selected as the ADC0 Reference Voltage
	ADC0.CTRLD = 0b00000000;	//Initial delay set to 0
	ADC0.EVCTRL = 0b00000001;	//Enable Event controlled start conversion (EVCTRL)
	ADC0.INTCTRL = 0b00000001;	//ADC Interrupt on Result Ready Enabled
}

void USART3_init(void) {
	PORTB.DIR &= ~PIN5_bm;
	PORTB.DIR |= PIN4_bm;
	USART3.BAUD = (uint16_t)USART3_BAUD_RATE(115200);
	USART3.CTRLB |= (USART_TXEN_bm | USART_RXEN_bm);
	PORTMUX.USARTROUTEA |= PORTMUX_USART3_ALT1_gc;
	USART3.CTRLA = USART_TXCIE_bm;
}

int main(void)
{
	//Call  Clock_Init() to ensure 20 MHz clock for CLK_CPU and CLK_PER
	clock_init();
	//Initialize Pin 1 of PORTA to output (needed as Servomotor PWM output), also set PORTA Pin 0 (LED bit 2), PORTF Pin 5 (LED bit 3), PORTA C Pin 6 (LED bit 4), and PORTF Pin 4 (LED bit 6) as outputs.
	init_outputs();
	//Initialize Timer/Counter TCA0 for Single Slope PWM with TCA0 clock set to CLK_PER Divided by 16 using WO-1 output on PORTA Pin 1
	WG_SSPWM_init();
	//Initialize Timer/Counter TCB0 for input capture combined Frequency and Pulse Width Measurement
	TCB0_init();
	//Initialize Timer/Counter TCB1 to detect TCB0 timeouts (Advanced feature).
	//TCB1_init();
	//Initialize Timer/Counter TCB3 for period timer mode to set a period of 5ms.
	TCB3_init();
	//Initialize USART Serial Port
	USART3_init();
	//Initialize ADC, automatic trigger set for Event Control, where the event is generated by TCB3 Timer overflow.
	ADC0_init();
	//Initialize Event Systems
	EVSYS_Init();
	//Enable global interrupts.
	sei();

	while(1)
	{
		if (USART3.STATUS & USART_RXCIF_bm)	//Test Serial port to check for new character and Parse input
		{
			input = USART3.RXDATAL;
			displayMessage(input);
		}
		if(continuousTimerMode)			//If the continuous timer value display (Continuous Timer Mode Set) is selected
		{
			if(newTimerDataFlag)		//Test New Input Capture data flag to see if new ICP data has been captured.
			{
				sprintf(message, "Time Period = %d us\n", period);
				sendmsg(message);		//Report new timer value to the user on the USART
				_delay_ms(50);
				newTimerDataFlag = 0;	//Clear the New Input Capture data flag
			}
		}
		else if(continuousADCMode)	//If the continuous ADC display (Continuous ADC Mode Set) is selected
		{
			if(newADCDataFlag)		//Test New ADC data flag to see if new ADC data has been captured.
			{
				sprintf(message, "Voltage = %d mV\n", adc_voltage);
				sendmsg(message);	//Report new ADC voltage to the user on the USART
				_delay_ms(50);
				newADCDataFlag = 0;	//Clear the ADC data flag
			}
		}
	}  
}

ISR(ADC0_RESRDY_vect)
{
	adc_result = ADC0.RES;									//Store ADC value into global variable
	double temp_voltage = ((5.0*adc_result)/1023.0)*1000.0;	//Convert ADC value into mV
	adc_voltage = (int)temp_voltage;
	newADCDataFlag = 1;										//Set new ADC_value flag
	if (adc_result > THREE_5V) {							//ADC value > 3.5V
		PORTF.OUTSET = 0b00010000;							//Turn on PORTF Pin 4 (LED bit 6)
	}
	else {
		PORTF.OUTCLR = 0b00010000;							//Turn off PORTF Pin 4 (LED bit 6)
	}
}

ISR(TCB0_INT_vect)
{
	TCB0.INTFLAGS = TCB_CAPT_bm;			//Clear the interrupt flag
	uint16_t Pulse_Width = TCB0.CCMP/10;	//Convert to microseconds 
	period = TCB0.CNT/10;					//Convert to microseconds
	highTime = (period - Pulse_Width);				
	lowTime = (Pulse_Width);
	newTimerDataFlag = 1;					//Set New Input Capture data flag	
	if (period > 150) {						//Input time period > 150 us
		PORTA.OUTSET = 0b00000001;			//Turn on PORTA Pin 0 (LED bit 2)
	}
	else {
		PORTA.OUTCLR = 0b00000001;			//Turn off PORTA Pin 0 (LED bit 2)
	}
	if (period > 320) {						//Input time period > 320 us
		PORTF.OUTSET = 0b00100000;			//Turn on PORTF Pin 5 (LED bit 3)
	}
	else {
		PORTF.OUTCLR = 0b00100000;			//Turn off PORTF Pin 5 (LED bit 3)
	}
	PORTC.OUTCLR = 0b01000000;				//Turn off PORTC Pin 6 (LED bit 4)
}

ISR(TCB1_INT_vect)
{
	//Challenge use TCB1 to detect if the 555 timer has stopped oscillating and Turn on PORTC Pin 6 if yes
}

ISR(TCB3_INT_vect)
{
	TCB3.INTFLAGS = TCB_CAPT_bm;	//Reset the TCB3 Interrupt Flag using TCB3.INTFLAGS
	interruptCounter++;				//Increment a software interrupt counter
	//Compare with the value selected by the user when entering numbers ‘0’ to ‘9’.
	if((interruptCounter >= numberOfInterrupts) && (stopServo == 0)){
		if(leftOrRight == 0){
			if(servoCounter == MAXCOUNT){
				TCA0.SINGLE.CMP1BUF = 1250 + (STEP_SIZE * servoCounter);
				leftOrRight = 1;
				servoCounter--;
			}
			else {
				TCA0.SINGLE.CMP1BUF = 1250 + (STEP_SIZE * servoCounter);
				servoCounter++;
			}
		}
		if(leftOrRight == 1){
			if(servoCounter == 0){
				TCA0.SINGLE.CMP1BUF = 1250 + (STEP_SIZE * servoCounter);
				leftOrRight = 0;
				servoCounter++;
			}
			else {
				TCA0.SINGLE.CMP1BUF = 1250 + (STEP_SIZE * servoCounter);
				servoCounter--;
			}
		}
		interruptCounter = 0;	//Clear the software interrupt counter.
	}
}

ISR(USART3_TXC_vect)
{
	USART3.STATUS |= USART_TXCIF_bm;
	if (qcntr != sndcntr) {
		USART3.TXDATAL = queue[sndcntr++];
	}
}

void sendmsg (char *s)
{
	qcntr = 0;
	sndcntr = 1;
	while (*s) {
		queue[qcntr++] = *s++;
	}
	USART3.TXDATAL = queue[0];
}

void displayMessage(char input){
	if((input == 'T') || (input == 't'))
	{
		sprintf(message, "Time Period = %d us\n", period);
		sendmsg(message);
	}
	else if((input == 'L') || (input == 'l'))
	{
		sprintf(message, "Low time = %d us\n", lowTime);
		sendmsg(message);
	}
	else if((input == 'H') || (input == 'h'))
	{
		sprintf(message, "High Time = %d us\n", highTime);
		sendmsg(message);
	}
	else if((input == 'C') || (input == 'c'))
	{
		continuousTimerMode = 1;
	}
	else if((input == 'E') || (input == 'e'))
	{
		continuousTimerMode = 0;
	}
	else if((input == 'A') || (input == 'a'))
	{
		sprintf(message, "ADC Reading = %d\n", adc_result);
		sendmsg(message);
	}
	else if((input == 'V') || (input == 'v'))
	{
		sprintf(message, "Voltage = %d mV\n", adc_voltage);
		sendmsg(message);
	}
	else if((input == 'M') || (input == 'm'))
	{
		continuousADCMode = 1;
	}
	else if((input == 'N') || (input == 'n'))
	{
		continuousADCMode = 0;
	}
	else if(input == '9'){
		numberOfInterrupts = 10;
		stopServo = 0;
	}
	else if(input == '8'){
		numberOfInterrupts = 20;
		stopServo = 0;
	}
	else if(input =='7'){
		numberOfInterrupts = 30;
		stopServo = 0;
	}
	else if(input == '6'){
		numberOfInterrupts = 40;
		stopServo = 0;
	}
	else if(input == '5'){
		numberOfInterrupts = 50;
		stopServo = 0;
	}
	else if(input == '4'){
		numberOfInterrupts = 60;
		stopServo = 0;
	}
	else if(input == '3'){
		numberOfInterrupts = 80;
		stopServo = 0;
	}
	else if(input == '2'){
		numberOfInterrupts = 100;
		stopServo = 0;
	}
	else if(input == '1'){
		numberOfInterrupts = 200;
		stopServo = 0;
	}
	else if(input == '0'){
		stopServo = 1;
	}
}
