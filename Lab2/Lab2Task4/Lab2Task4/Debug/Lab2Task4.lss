
Lab2Task4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000001e  00802800  0000042c  000004a0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000042c  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .comment      00000030  00000000  00000000  000004be  2**0
                  CONTENTS, READONLY
  3 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000004f0  2**2
                  CONTENTS, READONLY
  4 .debug_aranges 00000068  00000000  00000000  00000530  2**3
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00002b76  00000000  00000000  00000598  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000024b0  00000000  00000000  0000310e  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000005d7  00000000  00000000  000055be  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000074  00000000  00000000  00005b98  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000012e3  00000000  00000000  00005c0c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000001da  00000000  00000000  00006eef  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000038  00000000  00000000  000070c9  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 50 00 	jmp	0xa0	; 0xa0 <__ctors_end>
   4:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
   8:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
   c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  10:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  14:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  18:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  1c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  20:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  24:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  28:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  2c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  30:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  34:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  38:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  3c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  40:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  44:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  48:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  4c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  50:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  54:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  58:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  5c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  60:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  64:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  68:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  6c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  70:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  74:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  78:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  7c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  80:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  84:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  88:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  8c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  90:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  94:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  98:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  9c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>

000000a0 <__ctors_end>:
  a0:	11 24       	eor	r1, r1
  a2:	1f be       	out	0x3f, r1	; 63
  a4:	cf ef       	ldi	r28, 0xFF	; 255
  a6:	cd bf       	out	0x3d, r28	; 61
  a8:	df e3       	ldi	r29, 0x3F	; 63
  aa:	de bf       	out	0x3e, r29	; 62

000000ac <__do_copy_data>:
  ac:	18 e2       	ldi	r17, 0x28	; 40
  ae:	a0 e0       	ldi	r26, 0x00	; 0
  b0:	b8 e2       	ldi	r27, 0x28	; 40
  b2:	ec e2       	ldi	r30, 0x2C	; 44
  b4:	f4 e0       	ldi	r31, 0x04	; 4
  b6:	02 c0       	rjmp	.+4      	; 0xbc <__do_copy_data+0x10>
  b8:	05 90       	lpm	r0, Z+
  ba:	0d 92       	st	X+, r0
  bc:	ae 31       	cpi	r26, 0x1E	; 30
  be:	b1 07       	cpc	r27, r17
  c0:	d9 f7       	brne	.-10     	; 0xb8 <__do_copy_data+0xc>
  c2:	0e 94 ed 01 	call	0x3da	; 0x3da <main>
  c6:	0c 94 14 02 	jmp	0x428	; 0x428 <_exit>

000000ca <__bad_interrupt>:
  ca:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ce <CLOCK_init>:


void CLOCK_init (void)
{
	/* Disable CLK_PER Prescaler */
	ccp_write_io( (void *) &CLKCTRL.MCLKCTRLB , (0 << CLKCTRL_PEN_bp));
  ce:	60 e0       	ldi	r22, 0x00	; 0
  d0:	81 e6       	ldi	r24, 0x61	; 97
  d2:	90 e0       	ldi	r25, 0x00	; 0
  d4:	0e 94 0e 02 	call	0x41c	; 0x41c <ccp_write_io>
  d8:	08 95       	ret

000000da <InitialiseLED_PORT_bits>:
void InitialiseLED_PORT_bits()
{
	/* This has the same effect as PORTS_init() in Lab2Task2, but uses an array for the LED bits */
	uint8_t i;
	
	for (i = 0; i <= (NUM_LED_BITS - 1); i += 1) {
  da:	80 e0       	ldi	r24, 0x00	; 0
  dc:	0f c0       	rjmp	.+30     	; 0xfc <InitialiseLED_PORT_bits+0x22>
		LED_Array[i].LED_PORT->DIRSET = LED_Array[i].bit_mapping;
  de:	e8 2f       	mov	r30, r24
  e0:	f0 e0       	ldi	r31, 0x00	; 0
  e2:	9f 01       	movw	r18, r30
  e4:	22 0f       	add	r18, r18
  e6:	33 1f       	adc	r19, r19
  e8:	e2 0f       	add	r30, r18
  ea:	f3 1f       	adc	r31, r19
  ec:	e0 50       	subi	r30, 0x00	; 0
  ee:	f8 4d       	sbci	r31, 0xD8	; 216
  f0:	a0 81       	ld	r26, Z
  f2:	b1 81       	ldd	r27, Z+1	; 0x01
  f4:	92 81       	ldd	r25, Z+2	; 0x02
  f6:	11 96       	adiw	r26, 0x01	; 1
  f8:	9c 93       	st	X, r25
void InitialiseLED_PORT_bits()
{
	/* This has the same effect as PORTS_init() in Lab2Task2, but uses an array for the LED bits */
	uint8_t i;
	
	for (i = 0; i <= (NUM_LED_BITS - 1); i += 1) {
  fa:	8f 5f       	subi	r24, 0xFF	; 255
  fc:	8a 30       	cpi	r24, 0x0A	; 10
  fe:	78 f3       	brcs	.-34     	; 0xde <InitialiseLED_PORT_bits+0x4>
		LED_Array[i].LED_PORT->DIRSET = LED_Array[i].bit_mapping;
	}
}
 100:	08 95       	ret

00000102 <InitialiseButton_PORT_bits>:


void InitialiseButton_PORT_bits(void)
{
	PORTE.DIRCLR = PIN1_bm | PIN2_bm;		/* PORTE bit 1 and bit 2 are inputs */
 102:	e0 e8       	ldi	r30, 0x80	; 128
 104:	f4 e0       	ldi	r31, 0x04	; 4
 106:	86 e0       	ldi	r24, 0x06	; 6
 108:	82 83       	std	Z+2, r24	; 0x02
	PORTE.PIN1CTRL |= PORT_PULLUPEN_bm;		/* Enable Pull up resistors on PORTE pins 1 & 2 */
 10a:	81 89       	ldd	r24, Z+17	; 0x11
 10c:	88 60       	ori	r24, 0x08	; 8
 10e:	81 8b       	std	Z+17, r24	; 0x11
	PORTE.PIN2CTRL |= PORT_PULLUPEN_bm;
 110:	82 89       	ldd	r24, Z+18	; 0x12
 112:	88 60       	ori	r24, 0x08	; 8
 114:	82 8b       	std	Z+18, r24	; 0x12
 116:	08 95       	ret

00000118 <move_leds>:
}

void move_leds(void)
{
	uint8_t i;
	if (PORTE.IN & PIN1_bm){
 118:	80 91 88 04 	lds	r24, 0x0488	; 0x800488 <__TEXT_REGION_LENGTH__+0x7f4488>
 11c:	81 fd       	sbrc	r24, 1
 11e:	4c c0       	rjmp	.+152    	; 0x1b8 <move_leds+0xa0>
 120:	20 e0       	ldi	r18, 0x00	; 0
 122:	e5 c0       	rjmp	.+458    	; 0x2ee <move_leds+0x1d6>
	for (i = 0; i < (NUM_LED_BITS - 1); i += 1)
		{
			if (i == 0){
 124:	21 11       	cpse	r18, r1
 126:	20 c0       	rjmp	.+64     	; 0x168 <move_leds+0x50>
				LED_Array[i+1].LED_PORT->OUTCLR = LED_Array[i+1].bit_mapping;
 128:	82 2f       	mov	r24, r18
 12a:	90 e0       	ldi	r25, 0x00	; 0
 12c:	ac 01       	movw	r20, r24
 12e:	4f 5f       	subi	r20, 0xFF	; 255
 130:	5f 4f       	sbci	r21, 0xFF	; 255
 132:	fa 01       	movw	r30, r20
 134:	ee 0f       	add	r30, r30
 136:	ff 1f       	adc	r31, r31
 138:	4e 0f       	add	r20, r30
 13a:	5f 1f       	adc	r21, r31
 13c:	fa 01       	movw	r30, r20
 13e:	e0 50       	subi	r30, 0x00	; 0
 140:	f8 4d       	sbci	r31, 0xD8	; 216
 142:	a0 81       	ld	r26, Z
 144:	b1 81       	ldd	r27, Z+1	; 0x01
 146:	32 81       	ldd	r19, Z+2	; 0x02
 148:	16 96       	adiw	r26, 0x06	; 6
 14a:	3c 93       	st	X, r19
				LED_Array[i].LED_PORT->OUTSET = LED_Array[i].bit_mapping;
 14c:	fc 01       	movw	r30, r24
 14e:	ee 0f       	add	r30, r30
 150:	ff 1f       	adc	r31, r31
 152:	8e 0f       	add	r24, r30
 154:	9f 1f       	adc	r25, r31
 156:	fc 01       	movw	r30, r24
 158:	e0 50       	subi	r30, 0x00	; 0
 15a:	f8 4d       	sbci	r31, 0xD8	; 216
 15c:	a0 81       	ld	r26, Z
 15e:	b1 81       	ldd	r27, Z+1	; 0x01
 160:	82 81       	ldd	r24, Z+2	; 0x02
 162:	15 96       	adiw	r26, 0x05	; 5
 164:	8c 93       	st	X, r24
 166:	1d c0       	rjmp	.+58     	; 0x1a2 <move_leds+0x8a>
			}
			else {
				LED_Array[i-1].LED_PORT->OUTCLR = LED_Array[i-1].bit_mapping;
 168:	82 2f       	mov	r24, r18
 16a:	90 e0       	ldi	r25, 0x00	; 0
 16c:	fc 01       	movw	r30, r24
 16e:	31 97       	sbiw	r30, 0x01	; 1
 170:	af 01       	movw	r20, r30
 172:	44 0f       	add	r20, r20
 174:	55 1f       	adc	r21, r21
 176:	e4 0f       	add	r30, r20
 178:	f5 1f       	adc	r31, r21
 17a:	e0 50       	subi	r30, 0x00	; 0
 17c:	f8 4d       	sbci	r31, 0xD8	; 216
 17e:	a0 81       	ld	r26, Z
 180:	b1 81       	ldd	r27, Z+1	; 0x01
 182:	32 81       	ldd	r19, Z+2	; 0x02
 184:	16 96       	adiw	r26, 0x06	; 6
 186:	3c 93       	st	X, r19
				LED_Array[i].LED_PORT->OUTSET = LED_Array[i].bit_mapping;
 188:	fc 01       	movw	r30, r24
 18a:	ee 0f       	add	r30, r30
 18c:	ff 1f       	adc	r31, r31
 18e:	8e 0f       	add	r24, r30
 190:	9f 1f       	adc	r25, r31
 192:	fc 01       	movw	r30, r24
 194:	e0 50       	subi	r30, 0x00	; 0
 196:	f8 4d       	sbci	r31, 0xD8	; 216
 198:	a0 81       	ld	r26, Z
 19a:	b1 81       	ldd	r27, Z+1	; 0x01
 19c:	82 81       	ldd	r24, Z+2	; 0x02
 19e:	15 96       	adiw	r26, 0x05	; 5
 1a0:	8c 93       	st	X, r24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 1a2:	3f e1       	ldi	r19, 0x1F	; 31
 1a4:	81 ea       	ldi	r24, 0xA1	; 161
 1a6:	97 e0       	ldi	r25, 0x07	; 7
 1a8:	31 50       	subi	r19, 0x01	; 1
 1aa:	80 40       	sbci	r24, 0x00	; 0
 1ac:	90 40       	sbci	r25, 0x00	; 0
 1ae:	e1 f7       	brne	.-8      	; 0x1a8 <move_leds+0x90>
 1b0:	00 c0       	rjmp	.+0      	; 0x1b2 <move_leds+0x9a>
 1b2:	00 00       	nop

void move_leds(void)
{
	uint8_t i;
	if (PORTE.IN & PIN1_bm){
	for (i = 0; i < (NUM_LED_BITS - 1); i += 1)
 1b4:	2f 5f       	subi	r18, 0xFF	; 255
 1b6:	01 c0       	rjmp	.+2      	; 0x1ba <move_leds+0xa2>
 1b8:	20 e0       	ldi	r18, 0x00	; 0
 1ba:	29 30       	cpi	r18, 0x09	; 9
 1bc:	08 f4       	brcc	.+2      	; 0x1c0 <move_leds+0xa8>
 1be:	b2 cf       	rjmp	.-156    	; 0x124 <move_leds+0xc>
 1c0:	29 e0       	ldi	r18, 0x09	; 9
 1c2:	49 c0       	rjmp	.+146    	; 0x256 <move_leds+0x13e>
		
			_delay_us(DELAY_EIGHTH_SEC);
		}
		for (i = (NUM_LED_BITS - 1); i > 0; i -= 1)
		{
			if (i == (NUM_LED_BITS - 1)){
 1c4:	29 30       	cpi	r18, 0x09	; 9
 1c6:	01 f5       	brne	.+64     	; 0x208 <move_leds+0xf0>
				LED_Array[i-1].LED_PORT->OUTCLR = LED_Array[i-1].bit_mapping;
 1c8:	82 2f       	mov	r24, r18
 1ca:	90 e0       	ldi	r25, 0x00	; 0
 1cc:	ac 01       	movw	r20, r24
 1ce:	41 50       	subi	r20, 0x01	; 1
 1d0:	51 09       	sbc	r21, r1
 1d2:	fa 01       	movw	r30, r20
 1d4:	ee 0f       	add	r30, r30
 1d6:	ff 1f       	adc	r31, r31
 1d8:	4e 0f       	add	r20, r30
 1da:	5f 1f       	adc	r21, r31
 1dc:	fa 01       	movw	r30, r20
 1de:	e0 50       	subi	r30, 0x00	; 0
 1e0:	f8 4d       	sbci	r31, 0xD8	; 216
 1e2:	a0 81       	ld	r26, Z
 1e4:	b1 81       	ldd	r27, Z+1	; 0x01
 1e6:	32 81       	ldd	r19, Z+2	; 0x02
 1e8:	16 96       	adiw	r26, 0x06	; 6
 1ea:	3c 93       	st	X, r19
				LED_Array[i].LED_PORT->OUTSET = LED_Array[i].bit_mapping;
 1ec:	fc 01       	movw	r30, r24
 1ee:	ee 0f       	add	r30, r30
 1f0:	ff 1f       	adc	r31, r31
 1f2:	8e 0f       	add	r24, r30
 1f4:	9f 1f       	adc	r25, r31
 1f6:	fc 01       	movw	r30, r24
 1f8:	e0 50       	subi	r30, 0x00	; 0
 1fa:	f8 4d       	sbci	r31, 0xD8	; 216
 1fc:	a0 81       	ld	r26, Z
 1fe:	b1 81       	ldd	r27, Z+1	; 0x01
 200:	82 81       	ldd	r24, Z+2	; 0x02
 202:	15 96       	adiw	r26, 0x05	; 5
 204:	8c 93       	st	X, r24
 206:	1d c0       	rjmp	.+58     	; 0x242 <move_leds+0x12a>
			}
			else {
				LED_Array[i+1].LED_PORT->OUTCLR = LED_Array[i+1].bit_mapping;
 208:	82 2f       	mov	r24, r18
 20a:	90 e0       	ldi	r25, 0x00	; 0
 20c:	fc 01       	movw	r30, r24
 20e:	31 96       	adiw	r30, 0x01	; 1
 210:	af 01       	movw	r20, r30
 212:	44 0f       	add	r20, r20
 214:	55 1f       	adc	r21, r21
 216:	e4 0f       	add	r30, r20
 218:	f5 1f       	adc	r31, r21
 21a:	e0 50       	subi	r30, 0x00	; 0
 21c:	f8 4d       	sbci	r31, 0xD8	; 216
 21e:	a0 81       	ld	r26, Z
 220:	b1 81       	ldd	r27, Z+1	; 0x01
 222:	32 81       	ldd	r19, Z+2	; 0x02
 224:	16 96       	adiw	r26, 0x06	; 6
 226:	3c 93       	st	X, r19
				LED_Array[i].LED_PORT->OUTSET = LED_Array[i].bit_mapping;
 228:	fc 01       	movw	r30, r24
 22a:	ee 0f       	add	r30, r30
 22c:	ff 1f       	adc	r31, r31
 22e:	8e 0f       	add	r24, r30
 230:	9f 1f       	adc	r25, r31
 232:	fc 01       	movw	r30, r24
 234:	e0 50       	subi	r30, 0x00	; 0
 236:	f8 4d       	sbci	r31, 0xD8	; 216
 238:	a0 81       	ld	r26, Z
 23a:	b1 81       	ldd	r27, Z+1	; 0x01
 23c:	82 81       	ldd	r24, Z+2	; 0x02
 23e:	15 96       	adiw	r26, 0x05	; 5
 240:	8c 93       	st	X, r24
 242:	3f e1       	ldi	r19, 0x1F	; 31
 244:	81 ea       	ldi	r24, 0xA1	; 161
 246:	97 e0       	ldi	r25, 0x07	; 7
 248:	31 50       	subi	r19, 0x01	; 1
 24a:	80 40       	sbci	r24, 0x00	; 0
 24c:	90 40       	sbci	r25, 0x00	; 0
 24e:	e1 f7       	brne	.-8      	; 0x248 <move_leds+0x130>
 250:	00 c0       	rjmp	.+0      	; 0x252 <move_leds+0x13a>
 252:	00 00       	nop
				LED_Array[i].LED_PORT->OUTSET = LED_Array[i].bit_mapping;
			}
		
			_delay_us(DELAY_EIGHTH_SEC);
		}
		for (i = (NUM_LED_BITS - 1); i > 0; i -= 1)
 254:	21 50       	subi	r18, 0x01	; 1
 256:	21 11       	cpse	r18, r1
 258:	b5 cf       	rjmp	.-150    	; 0x1c4 <move_leds+0xac>
 25a:	08 95       	ret
		}
	}
	else{
		for (i = 0; i < (NUM_LED_BITS - 1); i += 1)
		{
			if (i == 0){
 25c:	21 11       	cpse	r18, r1
 25e:	20 c0       	rjmp	.+64     	; 0x2a0 <move_leds+0x188>
				LED_Array[i+1].LED_PORT->OUTSET = LED_Array[i+1].bit_mapping;
 260:	82 2f       	mov	r24, r18
 262:	90 e0       	ldi	r25, 0x00	; 0
 264:	ac 01       	movw	r20, r24
 266:	4f 5f       	subi	r20, 0xFF	; 255
 268:	5f 4f       	sbci	r21, 0xFF	; 255
 26a:	fa 01       	movw	r30, r20
 26c:	ee 0f       	add	r30, r30
 26e:	ff 1f       	adc	r31, r31
 270:	4e 0f       	add	r20, r30
 272:	5f 1f       	adc	r21, r31
 274:	fa 01       	movw	r30, r20
 276:	e0 50       	subi	r30, 0x00	; 0
 278:	f8 4d       	sbci	r31, 0xD8	; 216
 27a:	a0 81       	ld	r26, Z
 27c:	b1 81       	ldd	r27, Z+1	; 0x01
 27e:	32 81       	ldd	r19, Z+2	; 0x02
 280:	15 96       	adiw	r26, 0x05	; 5
 282:	3c 93       	st	X, r19
				LED_Array[i].LED_PORT->OUTCLR = LED_Array[i].bit_mapping;
 284:	fc 01       	movw	r30, r24
 286:	ee 0f       	add	r30, r30
 288:	ff 1f       	adc	r31, r31
 28a:	8e 0f       	add	r24, r30
 28c:	9f 1f       	adc	r25, r31
 28e:	fc 01       	movw	r30, r24
 290:	e0 50       	subi	r30, 0x00	; 0
 292:	f8 4d       	sbci	r31, 0xD8	; 216
 294:	a0 81       	ld	r26, Z
 296:	b1 81       	ldd	r27, Z+1	; 0x01
 298:	82 81       	ldd	r24, Z+2	; 0x02
 29a:	16 96       	adiw	r26, 0x06	; 6
 29c:	8c 93       	st	X, r24
 29e:	1d c0       	rjmp	.+58     	; 0x2da <move_leds+0x1c2>
			}
			else {
				LED_Array[i-1].LED_PORT->OUTSET = LED_Array[i-1].bit_mapping;
 2a0:	82 2f       	mov	r24, r18
 2a2:	90 e0       	ldi	r25, 0x00	; 0
 2a4:	fc 01       	movw	r30, r24
 2a6:	31 97       	sbiw	r30, 0x01	; 1
 2a8:	af 01       	movw	r20, r30
 2aa:	44 0f       	add	r20, r20
 2ac:	55 1f       	adc	r21, r21
 2ae:	e4 0f       	add	r30, r20
 2b0:	f5 1f       	adc	r31, r21
 2b2:	e0 50       	subi	r30, 0x00	; 0
 2b4:	f8 4d       	sbci	r31, 0xD8	; 216
 2b6:	a0 81       	ld	r26, Z
 2b8:	b1 81       	ldd	r27, Z+1	; 0x01
 2ba:	32 81       	ldd	r19, Z+2	; 0x02
 2bc:	15 96       	adiw	r26, 0x05	; 5
 2be:	3c 93       	st	X, r19
				LED_Array[i].LED_PORT->OUTCLR = LED_Array[i].bit_mapping;
 2c0:	fc 01       	movw	r30, r24
 2c2:	ee 0f       	add	r30, r30
 2c4:	ff 1f       	adc	r31, r31
 2c6:	8e 0f       	add	r24, r30
 2c8:	9f 1f       	adc	r25, r31
 2ca:	fc 01       	movw	r30, r24
 2cc:	e0 50       	subi	r30, 0x00	; 0
 2ce:	f8 4d       	sbci	r31, 0xD8	; 216
 2d0:	a0 81       	ld	r26, Z
 2d2:	b1 81       	ldd	r27, Z+1	; 0x01
 2d4:	82 81       	ldd	r24, Z+2	; 0x02
 2d6:	16 96       	adiw	r26, 0x06	; 6
 2d8:	8c 93       	st	X, r24
 2da:	3f e1       	ldi	r19, 0x1F	; 31
 2dc:	81 ea       	ldi	r24, 0xA1	; 161
 2de:	97 e0       	ldi	r25, 0x07	; 7
 2e0:	31 50       	subi	r19, 0x01	; 1
 2e2:	80 40       	sbci	r24, 0x00	; 0
 2e4:	90 40       	sbci	r25, 0x00	; 0
 2e6:	e1 f7       	brne	.-8      	; 0x2e0 <move_leds+0x1c8>
 2e8:	00 c0       	rjmp	.+0      	; 0x2ea <move_leds+0x1d2>
 2ea:	00 00       	nop
			
			_delay_us(DELAY_EIGHTH_SEC);
		}
	}
	else{
		for (i = 0; i < (NUM_LED_BITS - 1); i += 1)
 2ec:	2f 5f       	subi	r18, 0xFF	; 255
 2ee:	29 30       	cpi	r18, 0x09	; 9
 2f0:	08 f4       	brcc	.+2      	; 0x2f4 <move_leds+0x1dc>
 2f2:	b4 cf       	rjmp	.-152    	; 0x25c <move_leds+0x144>
 2f4:	29 e0       	ldi	r18, 0x09	; 9
 2f6:	49 c0       	rjmp	.+146    	; 0x38a <move_leds+0x272>
			
			_delay_us(DELAY_EIGHTH_SEC);
		}
		for (i = (NUM_LED_BITS - 1); i > 0; i -= 1)
		{
			if (i == (NUM_LED_BITS - 1)){
 2f8:	29 30       	cpi	r18, 0x09	; 9
 2fa:	01 f5       	brne	.+64     	; 0x33c <move_leds+0x224>
				LED_Array[i-1].LED_PORT->OUTSET = LED_Array[i-1].bit_mapping;
 2fc:	82 2f       	mov	r24, r18
 2fe:	90 e0       	ldi	r25, 0x00	; 0
 300:	ac 01       	movw	r20, r24
 302:	41 50       	subi	r20, 0x01	; 1
 304:	51 09       	sbc	r21, r1
 306:	fa 01       	movw	r30, r20
 308:	ee 0f       	add	r30, r30
 30a:	ff 1f       	adc	r31, r31
 30c:	4e 0f       	add	r20, r30
 30e:	5f 1f       	adc	r21, r31
 310:	fa 01       	movw	r30, r20
 312:	e0 50       	subi	r30, 0x00	; 0
 314:	f8 4d       	sbci	r31, 0xD8	; 216
 316:	a0 81       	ld	r26, Z
 318:	b1 81       	ldd	r27, Z+1	; 0x01
 31a:	32 81       	ldd	r19, Z+2	; 0x02
 31c:	15 96       	adiw	r26, 0x05	; 5
 31e:	3c 93       	st	X, r19
				LED_Array[i].LED_PORT->OUTCLR = LED_Array[i].bit_mapping;
 320:	fc 01       	movw	r30, r24
 322:	ee 0f       	add	r30, r30
 324:	ff 1f       	adc	r31, r31
 326:	8e 0f       	add	r24, r30
 328:	9f 1f       	adc	r25, r31
 32a:	fc 01       	movw	r30, r24
 32c:	e0 50       	subi	r30, 0x00	; 0
 32e:	f8 4d       	sbci	r31, 0xD8	; 216
 330:	a0 81       	ld	r26, Z
 332:	b1 81       	ldd	r27, Z+1	; 0x01
 334:	82 81       	ldd	r24, Z+2	; 0x02
 336:	16 96       	adiw	r26, 0x06	; 6
 338:	8c 93       	st	X, r24
 33a:	1d c0       	rjmp	.+58     	; 0x376 <move_leds+0x25e>
			}
			else {
				LED_Array[i+1].LED_PORT->OUTSET = LED_Array[i+1].bit_mapping;
 33c:	82 2f       	mov	r24, r18
 33e:	90 e0       	ldi	r25, 0x00	; 0
 340:	fc 01       	movw	r30, r24
 342:	31 96       	adiw	r30, 0x01	; 1
 344:	af 01       	movw	r20, r30
 346:	44 0f       	add	r20, r20
 348:	55 1f       	adc	r21, r21
 34a:	e4 0f       	add	r30, r20
 34c:	f5 1f       	adc	r31, r21
 34e:	e0 50       	subi	r30, 0x00	; 0
 350:	f8 4d       	sbci	r31, 0xD8	; 216
 352:	a0 81       	ld	r26, Z
 354:	b1 81       	ldd	r27, Z+1	; 0x01
 356:	32 81       	ldd	r19, Z+2	; 0x02
 358:	15 96       	adiw	r26, 0x05	; 5
 35a:	3c 93       	st	X, r19
				LED_Array[i].LED_PORT->OUTCLR = LED_Array[i].bit_mapping;
 35c:	fc 01       	movw	r30, r24
 35e:	ee 0f       	add	r30, r30
 360:	ff 1f       	adc	r31, r31
 362:	8e 0f       	add	r24, r30
 364:	9f 1f       	adc	r25, r31
 366:	fc 01       	movw	r30, r24
 368:	e0 50       	subi	r30, 0x00	; 0
 36a:	f8 4d       	sbci	r31, 0xD8	; 216
 36c:	a0 81       	ld	r26, Z
 36e:	b1 81       	ldd	r27, Z+1	; 0x01
 370:	82 81       	ldd	r24, Z+2	; 0x02
 372:	16 96       	adiw	r26, 0x06	; 6
 374:	8c 93       	st	X, r24
 376:	3f e1       	ldi	r19, 0x1F	; 31
 378:	81 ea       	ldi	r24, 0xA1	; 161
 37a:	97 e0       	ldi	r25, 0x07	; 7
 37c:	31 50       	subi	r19, 0x01	; 1
 37e:	80 40       	sbci	r24, 0x00	; 0
 380:	90 40       	sbci	r25, 0x00	; 0
 382:	e1 f7       	brne	.-8      	; 0x37c <move_leds+0x264>
 384:	00 c0       	rjmp	.+0      	; 0x386 <move_leds+0x26e>
 386:	00 00       	nop
				LED_Array[i].LED_PORT->OUTCLR = LED_Array[i].bit_mapping;
			}
			
			_delay_us(DELAY_EIGHTH_SEC);
		}
		for (i = (NUM_LED_BITS - 1); i > 0; i -= 1)
 388:	21 50       	subi	r18, 0x01	; 1
 38a:	21 11       	cpse	r18, r1
 38c:	b5 cf       	rjmp	.-150    	; 0x2f8 <move_leds+0x1e0>
 38e:	08 95       	ret

00000390 <Set_Clear_Ports>:
/* Function to set or clear all LED port bits, 1 - set, 0 - clear */ 
void Set_Clear_Ports(uint8_t set) {
	
	uint8_t i;
	
	for (i = 0; i <= (NUM_LED_BITS - 1); i += 1)
 390:	90 e0       	ldi	r25, 0x00	; 0
 392:	20 c0       	rjmp	.+64     	; 0x3d4 <Set_Clear_Ports+0x44>
	{
		if (set)
 394:	88 23       	and	r24, r24
 396:	79 f0       	breq	.+30     	; 0x3b6 <Set_Clear_Ports+0x26>
			LED_Array[i].LED_PORT->OUTSET = LED_Array[i].bit_mapping;
 398:	e9 2f       	mov	r30, r25
 39a:	f0 e0       	ldi	r31, 0x00	; 0
 39c:	9f 01       	movw	r18, r30
 39e:	22 0f       	add	r18, r18
 3a0:	33 1f       	adc	r19, r19
 3a2:	e2 0f       	add	r30, r18
 3a4:	f3 1f       	adc	r31, r19
 3a6:	e0 50       	subi	r30, 0x00	; 0
 3a8:	f8 4d       	sbci	r31, 0xD8	; 216
 3aa:	a0 81       	ld	r26, Z
 3ac:	b1 81       	ldd	r27, Z+1	; 0x01
 3ae:	22 81       	ldd	r18, Z+2	; 0x02
 3b0:	15 96       	adiw	r26, 0x05	; 5
 3b2:	2c 93       	st	X, r18
 3b4:	0e c0       	rjmp	.+28     	; 0x3d2 <Set_Clear_Ports+0x42>
		else
			LED_Array[i].LED_PORT->OUTCLR = LED_Array[i].bit_mapping;
 3b6:	e9 2f       	mov	r30, r25
 3b8:	f0 e0       	ldi	r31, 0x00	; 0
 3ba:	9f 01       	movw	r18, r30
 3bc:	22 0f       	add	r18, r18
 3be:	33 1f       	adc	r19, r19
 3c0:	e2 0f       	add	r30, r18
 3c2:	f3 1f       	adc	r31, r19
 3c4:	e0 50       	subi	r30, 0x00	; 0
 3c6:	f8 4d       	sbci	r31, 0xD8	; 216
 3c8:	a0 81       	ld	r26, Z
 3ca:	b1 81       	ldd	r27, Z+1	; 0x01
 3cc:	22 81       	ldd	r18, Z+2	; 0x02
 3ce:	16 96       	adiw	r26, 0x06	; 6
 3d0:	2c 93       	st	X, r18
/* Function to set or clear all LED port bits, 1 - set, 0 - clear */ 
void Set_Clear_Ports(uint8_t set) {
	
	uint8_t i;
	
	for (i = 0; i <= (NUM_LED_BITS - 1); i += 1)
 3d2:	9f 5f       	subi	r25, 0xFF	; 255
 3d4:	9a 30       	cpi	r25, 0x0A	; 10
 3d6:	f0 f2       	brcs	.-68     	; 0x394 <Set_Clear_Ports+0x4>
		if (set)
			LED_Array[i].LED_PORT->OUTSET = LED_Array[i].bit_mapping;
		else
			LED_Array[i].LED_PORT->OUTCLR = LED_Array[i].bit_mapping;
	}
}
 3d8:	08 95       	ret

000003da <main>:
	PORTE.PIN2CTRL |= PORT_PULLUPEN_bm;
}

int main(void)
{
	CLOCK_init();
 3da:	0e 94 67 00 	call	0xce	; 0xce <CLOCK_init>
	
	/* set UNO D0-D7 to all outputs, also LED8 and LED9  */
	InitialiseLED_PORT_bits();
 3de:	0e 94 6d 00 	call	0xda	; 0xda <InitialiseLED_PORT_bits>
	/* Initialise Push Button bits and pull up resistors */
	InitialiseButton_PORT_bits();
 3e2:	0e 94 81 00 	call	0x102	; 0x102 <InitialiseButton_PORT_bits>
	
	Set_Clear_Ports(1);
 3e6:	81 e0       	ldi	r24, 0x01	; 1
 3e8:	0e 94 c8 01 	call	0x390	; 0x390 <Set_Clear_Ports>
 3ec:	2f ef       	ldi	r18, 0xFF	; 255
 3ee:	88 e0       	ldi	r24, 0x08	; 8
 3f0:	9d e3       	ldi	r25, 0x3D	; 61
 3f2:	21 50       	subi	r18, 0x01	; 1
 3f4:	80 40       	sbci	r24, 0x00	; 0
 3f6:	90 40       	sbci	r25, 0x00	; 0
 3f8:	e1 f7       	brne	.-8      	; 0x3f2 <main+0x18>
 3fa:	00 c0       	rjmp	.+0      	; 0x3fc <main+0x22>
 3fc:	00 00       	nop
	_delay_us(DELAY_ONE_SEC);
	
	Set_Clear_Ports(0);
 3fe:	80 e0       	ldi	r24, 0x00	; 0
 400:	0e 94 c8 01 	call	0x390	; 0x390 <Set_Clear_Ports>
 404:	2f ef       	ldi	r18, 0xFF	; 255
 406:	88 e0       	ldi	r24, 0x08	; 8
 408:	9d e3       	ldi	r25, 0x3D	; 61
 40a:	21 50       	subi	r18, 0x01	; 1
 40c:	80 40       	sbci	r24, 0x00	; 0
 40e:	90 40       	sbci	r25, 0x00	; 0
 410:	e1 f7       	brne	.-8      	; 0x40a <__LOCK_REGION_LENGTH__+0xa>
 412:	00 c0       	rjmp	.+0      	; 0x414 <__LOCK_REGION_LENGTH__+0x14>
 414:	00 00       	nop
	_delay_us(DELAY_ONE_SEC);
	
	while(1)
	{
		move_leds();
 416:	0e 94 8c 00 	call	0x118	; 0x118 <move_leds>
 41a:	fd cf       	rjmp	.-6      	; 0x416 <__LOCK_REGION_LENGTH__+0x16>

0000041c <ccp_write_io>:
 41c:	dc 01       	movw	r26, r24
 41e:	28 ed       	ldi	r18, 0xD8	; 216
 420:	20 93 34 00 	sts	0x0034, r18	; 0x800034 <__TEXT_REGION_LENGTH__+0x7f4034>
 424:	6c 93       	st	X, r22
 426:	08 95       	ret

00000428 <_exit>:
 428:	f8 94       	cli

0000042a <__stop_program>:
 42a:	ff cf       	rjmp	.-2      	; 0x42a <__stop_program>
